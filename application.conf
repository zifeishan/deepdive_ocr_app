deepdive {

  db.default: {
    driver: "org.postgresql.Driver"
    url: "jdbc:postgresql://127.0.0.1:5432/ddocr"
    user: ${PGUSER}
    password: ${PGPASSWORD}
  }

  schema.variables {
    # labels
    # filtered_labels.label_t: Boolean
    # filtered_labels.label_c: Boolean
    cand_label.label: Boolean
  }

  extraction.extractors: {

    # Extract naive ocr-specific features
    ext_naivefeature {
      input: "SELECT * from candidate;"
      # input: "SELECT * from candidate where docid = 'JOURNAL_102371';"
      output_relation: "feature"
      before: ${APP_HOME}"/udf/before_naivefeature.sh"
      udf: ${APP_HOME}"/udf/ext_naivefeature.py"
    }

    ext_cand_label {
      input: "SELECT id from candidate;"
      # input: "SELECT * from candidate where docid = 'JOURNAL_102371';"
      output_relation: "cand_label"
      before: ${APP_HOME}"/udf/before_cand_label.sh"
      udf: ${APP_HOME}"/udf/ext_cand_label.py"
    }


    # ext_feature_select {
    #   input: "SELECT * FROM features "
    #   output_relation: "filtered_features"
    #   udf: ${APP_HOME}"/udf/feature_select.py"
    #   before: ${APP_HOME}"/udf/before_feature_select.sh"
    # }

    ext_disagree_words {
      input: """SELECT options.docid, options.wordid, label_t, label_c
        FROM options INNER JOIN labels ON (options.docid = labels.docid
          AND options.wordid = labels.wordid)
        WHERE options.option_t != options.option_c; """
      output_relation: "filtered_labels"
      before: ${APP_HOME}"/udf/clean_filtered_labels.sh"
      udf: ${APP_HOME}"/udf/ext_filtered_labels.py"
      after: ${APP_HOME}"/udf/kfold.py "${KFOLD_NUM}" "${KFOLD_ITER}" filtered_labels label_t label_c"
      # udf: "/bin/cat"
    }
    ext_all_words {
      input: "SELECT * from labels;"
      output_relation: "filtered_labels"
      before: ${APP_HOME}"/udf/clean_filtered_labels.sh"
      udf: ${APP_HOME}"/udf/ext_filtered_labels.py"
      after: ${APP_HOME}"/udf/kfold.py "${KFOLD_NUM}" "${KFOLD_ITER}"filtered_labels label_t label_c"
      # udf: "/bin/cat"
    }
  }

  inference.factors: {

    f_naivefeature {
      input_query: """
        select * from feature join cand_label on feature.candidateid = cand_label.id limit 100;
        """
      function: "IsTrue(cand_label.label)"
      weight: "?(features.fname)"
    }

    f_simple_constraint {
      input_query: """
        select c1.id, c2.id, c1.label, c2.label from (candidate natural join cand_label) as c1 join (candidate natural join cand_label) as c2 
          on c1.docid = c2.docid 
          and c1.wordid = c2.wordid 
          and c1.candid != c2.candid;
        """
      function: "Imply(c1.label, c2.label)"
      weight: "?"
    }

    # Baseline: Features imply Labels
    f_label_t {
      input_query: """
        SELECT features.*, filtered_labels.* FROM features INNER JOIN filtered_labels
        ON ( features.docid = filtered_labels.docid AND
          features.wordid = filtered_labels.wordid ) 
        WHERE features.feature_val = true;
        """
      function: "IsTrue(filtered_labels.label_t)"
      weight: "?(features.feature_name)"
    }

    f_label_c {
      input_query: """
        SELECT features.*, filtered_labels.* FROM features INNER JOIN filtered_labels
        ON ( features.docid = filtered_labels.docid AND
          features.wordid = filtered_labels.wordid ) 
        WHERE features.feature_val = true;
        """
      function: "IsTrue(filtered_labels.label_c)"
      weight: "?(features.feature_name)"
    }

    # Rule 1: Frequent 1-gram imply Labels
    f_1gram_t {
      input_query: """
        SELECT filtered_labels.id, options.docid, options.wordid, options.option_t, filtered_labels.label_t
        FROM 
          (options INNER JOIN filtered_labels 
            ON options.docid = filtered_labels.docid 
              AND options.wordid = filtered_labels.wordid ) 
          INNER JOIN ngram_1 
          ON ngram_1.gram = options.option_t
        WHERE ngram_1.count > 1000;
        """
      function: "IsTrue(filtered_labels.label_t)"
      weight: "?"
    }
    f_1gram_c {
      input_query: """
        SELECT filtered_labels.id, options.docid, options.wordid, options.option_t, filtered_labels.label_c
        FROM 
          (options INNER JOIN filtered_labels 
            ON options.docid = filtered_labels.docid 
              AND options.wordid = filtered_labels.wordid ) 
          INNER JOIN ngram_1 
        ON ngram_1.gram = options.option_c
        WHERE ngram_1.count > 1000;
        """
      function: "IsTrue(filtered_labels.label_c)"
      weight: "?"
    }
    # Rule 2: Infrequent 1-gram imply False 
    f_1gram_tn {
      input_query: """
        SELECT filtered_labels.id, options.docid, options.wordid, options.option_t, filtered_labels.label_t
        FROM 
          (options INNER JOIN filtered_labels 
            ON options.docid = filtered_labels.docid 
              AND options.wordid = filtered_labels.wordid ) 
          INNER JOIN ngram_1 
          ON ngram_1.gram = options.option_t
        WHERE ngram_1.count <= 1000;
        """
      function: "IsTrue(!filtered_labels.label_t)"
      weight: "?"
    }
    f_1gram_cn {
      input_query: """
        SELECT filtered_labels.id, options.docid, options.wordid, options.option_t, filtered_labels.label_c
        FROM 
          (options INNER JOIN filtered_labels 
            ON options.docid = filtered_labels.docid 
              AND options.wordid = filtered_labels.wordid ) 
          INNER JOIN ngram_1 
          ON ngram_1.gram = options.option_c
        WHERE ngram_1.count <= 1000;
        """
      function: "IsTrue(filtered_labels.label_c)"
      weight: "?"
    }

    # Rule 2: Conflicts
    f_conflict_ct {
      input_query: """
        SELECT filtered_labels.id, options.docid, options.wordid, options.option_t, filtered_labels.label_c
        FROM 
          options INNER JOIN filtered_labels 
            ON options.docid = filtered_labels.docid 
            AND options.wordid = filtered_labels.wordid 
        WHERE options.option_t != options.option_c;
        """
      function: "Imply(filtered_labels.label_c, !filtered_labels.label_t)"
      weight: "100"
    }
    f_conflict_tc {
      input_query: """
        SELECT filtered_labels.id, options.docid, options.wordid, options.option_t, filtered_labels.label_c
        FROM 
          options INNER JOIN filtered_labels 
            ON options.docid = filtered_labels.docid 
            AND options.wordid = filtered_labels.wordid 
        WHERE options.option_t != options.option_c;
        """
      function: "Imply(filtered_labels.label_c, !filtered_labels.label_t)"
      weight: "100"
    }
  }

  calibration.holdout_fraction: ${CALI_FRACTION}

  sampler.sampler_args: "-l 1000 -s 10 -i 100"
  # sampler.sampler_args: "-l 1000 -s 10 -i 1000"

  pipeline.pipelines.allwords: ["ext_all_words", "f_label_t", "f_label_c"]
  pipeline.pipelines.disagree: ["ext_disagree_words", "f_label_t", "f_label_c"]

  pipeline.pipelines.1gram: ["ext_disagree_words", "f_label_t", "f_label_c", "f_1gram_t", "f_1gram_c", "f_1gram_tn", "f_1gram_cn"]

  pipeline.pipelines.conflict: ["ext_disagree_words", "f_label_t", "f_label_c", "f_1gram_t", "f_1gram_c", "f_1gram_tn", "f_1gram_cn", "f_conflict_tc", "f_conflict_ct"]

  pipeline.pipelines.gramonly: ["ext_disagree_words", "f_1gram_t", "f_1gram_c", "f_1gram_tn", "f_1gram_cn"]

  pipeline.pipelines.naiveextract: ["ext_naivefeature"]

  pipeline.pipelines.label: ["ext_cand_label", "f_naivefeature", "f_simple_constraint"]
  pipeline.pipelines.empty: []

  pipeline.run: "label"
  # pipeline.run: "gramonly"

}