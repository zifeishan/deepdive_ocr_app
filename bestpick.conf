deepdive {

  db.default: {
    driver: "org.postgresql.Driver"
    url: "jdbc:postgresql://"${PGHOST}":"${PGPORT}"/"${DBNAME} #"
    user: ${PGUSER}
    password: ${PGPASSWORD}
    dbname: ${DBNAME}
    host: ${PGHOST}
    port: ${PGPORT}
  }


  extraction.extractors: {

    # array_agg(id order by varid, candid, wordid) as arr_id,
    # array_agg(candid order by varid, candid, wordid) as arr_candid,
    # array_agg(wordid order by varid, candid, wordid) as arr_wordid,
    # TAKES VERY LONG
    ########### TODO at least change this to TSV... ############
    # ext_sup_orderaware {
    #   dependencies: ["ext_holdout_document", "ext_prepare_document", "ext_holdout_from_orderaware", "ext_cand_gen"]
    #   input: """select 
    #     docid,
    #     array_agg(candidate_id order by varid, candid, wordid) as arr_candidate_id,
    #     array_agg(varid order by varid, candid, wordid) as arr_varid,
    #     array_agg(word order by varid, candid, wordid) as arr_word
    #     from cand_word
    #     group by docid
    #     """
    #   # where docid in (select * from eval_docs)
    #   output_relation: "orderaware_supv_label"
    #   # Supervision dir
    #   # udf: "pypy "${APP_HOME}"/udf/ext_sup_orderaware.py"
    #   # get a sample..
    #   udf: util/extractor_input_writer.py /tmp/ext_sup_orderaware.input
    #   # # Using Evaluation dir
    #   # udf: "pypy "${APP_HOME}"/udf/ext_sup_orderaware.py "${EVAL_DIR}
    #   parallelism: ${MAX_PARALLELISM}
    #   before: ${APP_HOME}"/udf/before_sup_orderaware.sh"
    #   # after: ${APP_HOME}"/udf/after_sup_orderaware.sh"
    #   input_batch_size: 1
    #   output_batch_size: 10000
    # }

    # Use Levenshtein distance
    ext_eval_orderaware_bestpick {
      # style: "tsv_extractor"
      dependencies: []
      # input: """
      #   SELECT  docid,
      #           array_to_string(array_agg(varid order by varid, candid, wordid), ',' ) AS arr_varid,
      #           array_to_string(array_agg(candid order by varid, candid, wordid), ',' ) AS arr_candid,
      #           array_to_string(array_agg(wordid order by varid, candid, wordid), ',' ) AS arr_wordid,
      #           array_to_string(array_agg(word order by varid, candid, wordid), '~~~^^^~~~' ) AS arr_word
      #   FROM    cand_word
      #   WHERE   docid in (select * from eval_docs)
      #   AND     source not like '%Sg'
      #   GROUP BY docid
      #   """

      input: """select 
        docid,
        array_agg(candidate_id order by varid, candid, wordid) as arr_candidate_id,
        array_agg(varid order by varid, candid, wordid) as arr_varid,
        array_agg(word order by varid, candid, wordid) as arr_word
        from cand_word
        where docid in (select * from eval_docs)
        and source not like '%Sg'
        group by docid
        """  # TODO: Remove generated candidates!!
      output_relation: "orderaware_eval_label_bestpick"
      # udf: util/extractor_input_writer.py /tmp/ext_bestpick.input
      # udf: "pypy "${APP_HOME}"/udf/ext_sup_orderaware.py "${BESTPICK_DIR} ${EVAL_DIR} 0 0 ${BESTPICK_SAMPLE_SIZE}

      # FIND MATCHES (need to clean cand_word)
      udf: "pypy "${APP_HOME}"/udf/ext_sup_orderaware.py "${BESTPICK_DIR} ${EVAL_DIR} 0 3
      # udf: ${APP_HOME}"/udf/ext_sup_orderaware_fuzzy_cpp "${BESTPICK_DIR} ${EVAL_DIR} 0 3

      # # Opt(gen) Evaluation
      # udf: "pypy "${APP_HOME}"/udf/ext_sup_orderaware.py "${BESTPICK_DIR} ${EVAL_DIR} 0 0

      # udf: util/extractor_input_writer.py /tmp/sample_ext_ext_bestpick.txt
      parallelism: ${MAX_PARALLELISM}
      before: ${APP_HOME}"/udf/before_sup_orderaware_bestpick.sh orderaware_eval_label_bestpick"
      # after: ${APP_HOME}"/udf/after_sup_orderaware.sh"
      input_batch_size: 1
      output_batch_size: 10000
    }

    # Use Levenshtein distance
    ext_eval_orderaware_bestpick_evalgen {
      # style: "tsv_extractor"
      dependencies: []
      input: """select 
        docid,
        array_agg(candidate_id order by varid, candid, wordid) as arr_candidate_id,
        array_agg(varid order by varid, candid, wordid) as arr_varid,
        array_agg(word order by varid, candid, wordid) as arr_word
        from cand_word
        where docid in (select * from eval_docs)
        group by docid
        """
      # input: """
      #   SELECT  docid,
      #           array_to_string(array_agg(varid order by varid, candid, wordid), ',' ) AS arr_varid,
      #           array_to_string(array_agg(candid order by varid, candid, wordid), ',' ) AS arr_candid,
      #           array_to_string(array_agg(wordid order by varid, candid, wordid), ',' ) AS arr_wordid,
      #           array_to_string(array_agg(word order by varid, candid, wordid), '~~~^^^~~~' ) AS arr_word
      #   FROM    cand_word
      #   WHERE   docid in (select * from eval_docs)
      #   GROUP BY docid
      #   """

      # where docid in (select * from eval_docs)
      output_relation: "orderaware_eval_label_bestpick"
      # Opt(gen) Evaluation
      udf: "pypy "${APP_HOME}"/udf/ext_sup_orderaware.py "${BESTPICK_EVALGEN_DIR} ${EVAL_DIR} 0 0
      # udf: ${APP_HOME}"/udf/ext_sup_orderaware_fuzzy_cpp "${BESTPICK_EVALGEN_DIR} ${EVAL_DIR} 0 0

      # udf: util/extractor_input_writer.py /tmp/sample_ext_ext_bestpick.txt
      parallelism: ${MAX_PARALLELISM}
      before: ${APP_HOME}"/udf/before_sup_orderaware_bestpick.sh orderaware_eval_label_bestpick"
      # after: ${APP_HOME}"/udf/after_sup_orderaware.sh"
      input_batch_size: 1
      output_batch_size: 10000
    }

    # Use Levenshtein distance
    ext_eval_orderaware_bestpick_test_tess {
      # style: "tsv_extractor"
      dependencies: []
      # input: """
      #   SELECT  docid,
      #           array_to_string(array_agg(varid order by varid, candid, wordid), ',' ) AS arr_varid,
      #           array_to_string(array_agg(candid order by varid, candid, wordid), ',' ) AS arr_candid,
      #           array_to_string(array_agg(wordid order by varid, candid, wordid), ',' ) AS arr_wordid,
      #           array_to_string(array_agg(word order by varid, candid, wordid), '~~~^^^~~~' ) AS arr_word
      #   FROM    cand_word
      #   WHERE   docid in (select * from eval_docs)
      #   AND     (source = 'T' or source = 'CT')
      #   GROUP BY docid
      #   """
      input: """select 
        docid,
        array_agg(candidate_id order by varid, candid, wordid) as arr_candidate_id,
        array_agg(varid order by varid, candid, wordid) as arr_varid,
        array_agg(word order by varid, candid, wordid) as arr_word
        from cand_word
        where docid in (select * from eval_docs)
        and (source='T' or source='CT')
        group by docid
        """  # TODO: Remove generated candidates!!
      output_relation: "orderaware_eval_label_bestpick"
      # udf: util/extractor_input_writer.py /tmp/ext_bestpick.input
      # udf: "pypy "${APP_HOME}"/udf/ext_sup_orderaware.py "${BESTPICK_DIR} ${EVAL_DIR} 0 0 ${BESTPICK_SAMPLE_SIZE}

      # FIND MATCHES (need to clean cand_word)
      udf: "pypy "${APP_HOME}"/udf/ext_sup_orderaware.py "${BESTPICK_TESS_DIR} ${EVAL_DIR} 0 0
      # udf: ${APP_HOME}"/udf/ext_sup_orderaware_fuzzy_cpp "${BESTPICK_TESS_DIR} ${EVAL_DIR} 0 0

      parallelism: ${MAX_PARALLELISM}
      before: ${APP_HOME}"/udf/before_sup_orderaware_bestpick.sh orderaware_eval_label_bestpick"
      # after: ${APP_HOME}"/udf/after_sup_orderaware.sh"
      input_batch_size: 1
      output_batch_size: 10000
    }


    # Use trigram distance
    ext_eval_orderaware_bestpick_trgm {
      dependencies: []
      input: """select 
        docid,
        array_agg(candidate_id order by varid, candid, wordid) as arr_candidate_id,
        array_agg(varid order by varid, candid, wordid) as arr_varid,
        array_agg(word order by varid, candid, wordid) as arr_word
        from cand_word
        where docid in (select * from eval_docs)
        group by docid
        """
      # where docid in (select * from eval_docs)
      output_relation: "orderaware_eval_label_bestpick_trgm"
      # udf: util/extractor_input_writer.py /tmp/ext_bestpick.input
      udf: "pypy "${APP_HOME}"/udf/ext_sup_orderaware_trigramdist.py "${BESTPICK_DIR} ${EVAL_DIR} 0.1 0.9 0.2
      parallelism: ${MAX_PARALLELISM}
      before: ${APP_HOME}"/udf/before_sup_orderaware_bestpick.sh orderaware_eval_label_bestpick_trgm"
      # after: ${APP_HOME}"/udf/after_sup_orderaware.sh"
      input_batch_size: 1
      output_batch_size: 10000
    }


  }

  pipeline.pipelines.bestpick: [
    # "ext_eval_orderaware_bestpick",  # Evaluating original candidates
    "ext_eval_orderaware_bestpick_evalgen", # Eval generated cands
    # "ext_eval_orderaware_bestpick_test_tess",
    # "ext_eval_orderaware_bestpick_trgm",
    ]


  ########### pipeline.run: "bestpick"  # DANGER ZONE
  pipeline.run: "bestpick"


  # inference.skip_learning: true

  # pipeline.relearn_from: /lfs/madmax/0/zifei/deepdive/out/2014-05-29T020109
}
