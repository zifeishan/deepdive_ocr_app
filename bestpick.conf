deepdive {

  db.default: {
    driver: "org.postgresql.Driver"
    url: "jdbc:postgresql://"${PGHOST}":"${PGPORT}"/"${DBNAME} #"
    user: ${PGUSER}
    password: ${PGPASSWORD}
    dbname: ${DBNAME}
    host: ${PGHOST}
    port: ${PGPORT}
  }


  extraction.extractors: {

    # array_agg(id order by varid, candid, wordid) as arr_id,
    # array_agg(candid order by varid, candid, wordid) as arr_candid,
    # array_agg(wordid order by varid, candid, wordid) as arr_wordid,
    # TAKES VERY LONG
    ########### TODO at least change this to TSV... ############
    # ext_sup_orderaware {
    #   dependencies: ["ext_holdout_document", "ext_prepare_document", "ext_holdout_from_orderaware", "ext_cand_gen"]
    #   input: """select 
    #     docid,
    #     array_agg(candidate_id order by varid, candid, wordid) as arr_candidate_id,
    #     array_agg(varid order by varid, candid, wordid) as arr_varid,
    #     array_agg(word order by varid, candid, wordid) as arr_word
    #     from cand_word
    #     group by docid
    #     """
    #   # where docid in (select * from eval_docs)
    #   output_relation: "orderaware_supv_label"
    #   # Supervision dir
    #   # udf: "pypy "${APP_HOME}"/udf/ext_sup_orderaware.py"
    #   # get a sample..
    #   udf: util/extractor_input_writer.py /tmp/ext_sup_orderaware.input
    #   # # Using Evaluation dir
    #   # udf: "pypy "${APP_HOME}"/udf/ext_sup_orderaware.py "${EVAL_DIR}
    #   parallelism: ${MAX_PARALLELISM}
    #   before: ${APP_HOME}"/udf/before_sup_orderaware.sh"
    #   # after: ${APP_HOME}"/udf/after_sup_orderaware.sh"
    #   input_batch_size: 1
    #   output_batch_size: 10000
    # }

    ext_eval_orderaware_bestpick {
      dependencies: ["ext_holdout_document", "ext_prepare_document", "ext_holdout_from_orderaware"]
      input: """select 
        docid,
        array_agg(candidate_id order by varid, candid, wordid) as arr_candidate_id,
        array_agg(varid order by varid, candid, wordid) as arr_varid,
        array_agg(word order by varid, candid, wordid) as arr_word
        from cand_word
        where docid in (select * from eval_docs)
        group by docid
        """
      # where docid in (select * from eval_docs)
      output_relation: "orderaware_eval_label_bestpick"
      # udf: util/extractor_input_writer.py /tmp/ext_bestpick.input
      udf: "pypy "${APP_HOME}"/udf/ext_sup_orderaware.py "${BESTPICK_DIR} ${EVAL_DIR} 0 0 ${BESTPICK_SAMPLE_SIZE}
      parallelism: ${MAX_PARALLELISM}
      before: ${APP_HOME}"/udf/before_sup_orderaware_bestpick.sh orderaware_eval_label_bestpick"
      # after: ${APP_HOME}"/udf/after_sup_orderaware.sh"
      input_batch_size: 1
      output_batch_size: 10000
    }
    ext_eval_orderaware_bestpick_tess {
      dependencies: ["ext_holdout_document", "ext_prepare_document", "ext_holdout_from_orderaware"]
      input: """select 
        docid,
        array_agg(candidate_id order by varid, candid, wordid) as arr_candidate_id,
        array_agg(varid order by varid, candid, wordid) as arr_varid,
        array_agg(word order by varid, candid, wordid) as arr_word
        from cand_word
        where docid in (select * from eval_docs)
        and (source = 'T' or source = 'CT' or source = 'TC')
        group by docid
        """
      # where docid in (select * from eval_docs)
      output_relation: "orderaware_eval_label_bestpick_tess"
      udf: "pypy "${APP_HOME}"/udf/ext_sup_orderaware.py /lfs/local/0/zifei/bestpick-result-tess/ "${EVAL_DIR}
      parallelism: ${MAX_PARALLELISM}
      before: ${APP_HOME}"/udf/before_sup_orderaware_bestpick.sh orderaware_eval_label_bestpick_tess"
      # after: ${APP_HOME}"/udf/after_sup_orderaware.sh"
      input_batch_size: 1
      output_batch_size: 10000
    }
    ext_eval_orderaware_bestpick_cuni {
      dependencies: ["ext_holdout_document", "ext_prepare_document", "ext_holdout_from_orderaware"]
      input: """select 
        docid,
        array_agg(candidate_id order by varid, candid, wordid) as arr_candidate_id,
        array_agg(varid order by varid, candid, wordid) as arr_varid,
        array_agg(word order by varid, candid, wordid) as arr_word
        from cand_word
        where docid in (select * from eval_docs)
        and (source = 'C' or source = 'CT' or source = 'TC')
        group by docid
        """
      # where docid in (select * from eval_docs)
      output_relation: "orderaware_eval_label_bestpick_cuni"
      udf: "pypy "${APP_HOME}"/udf/ext_sup_orderaware.py /lfs/local/0/zifei/bestpick-result-cuni/ "${EVAL_DIR}
      parallelism: ${MAX_PARALLELISM}
      before: ${APP_HOME}"/udf/before_sup_orderaware_bestpick.sh orderaware_eval_label_bestpick_cuni"
      # after: ${APP_HOME}"/udf/after_sup_orderaware.sh"
      input_batch_size: 1
      output_batch_size: 10000
    }


    ext_sup_orderaware_incremental {
      dependencies: ["ext_holdout_document", "ext_prepare_document", "ext_holdout_from_orderaware"]
      input: """select 
        docid,
        array_agg(candidate_id order by varid, candid, wordid) as arr_candidate_id,
        array_agg(varid order by varid, candid, wordid) as arr_varid,
        array_agg(word order by varid, candid, wordid) as arr_word
        from cand_word
        where not exists
        (select DISTINCT docid from orderaware_supv_label
          where orderaware_supv_label.docid = cand_word.docid
          )
        group by docid
        """
        # TODO CHECK IT!!
      # where docid in (select * from eval_docs)
      output_relation: "orderaware_supv_label"
      udf: "pypy "${APP_HOME}"/udf/ext_sup_orderaware.py"
      parallelism: ${MAX_PARALLELISM}
      # before: ${APP_HOME}"/udf/before_sup_orderaware.sh"
      # after: ${APP_HOME}"/udf/after_sup_orderaware.sh"
      input_batch_size: 1
      output_batch_size: 10000
    }
    # NO EXTRACT, Use only
    # clean -> positive -> negative -> break ties (needed for new supv)
    ext_sup_use_orderaware {
      dependencies: ["ext_sup_orderaware"]
      style: "sql_extractor"
      sql: """
        UPDATE candidate SET label = NULL;

        UPDATE candidate
        SET label = true
        WHERE candidate_id IN 
        (select candidate_id from orderaware_supv_label where label = true);

        UPDATE  candidate c1
        SET     label = false 
        WHERE   label is null 
          AND   EXISTS (
            SELECT * 
            FROM candidate c2
            WHERE c1.docid = c2.docid
            AND   c1.variable_id = c2.variable_id
            AND   c1.candidate_id != c2.candidate_id
            AND   c2.label = true
            );

        UPDATE candidate AS c1
        SET    label = null
        FROM   candidate AS c2
        WHERE  c1.docid = c2.docid
          AND  c1.variable_id = c2.variable_id
          AND  c1.candidate_id != c2.candidate_id
          AND  c1.label = true
          AND  c2.label = true;

      """  # Current idea: only label ALTERNATIVES as false when a true one is found!


      # Previous idea: label all others as false in this document!!
      # THIS IS NOT CORRECT. Since data is not perfectly aligned!!
      # update candidate 
      #   set label = false 
      #   where label is null 
      #     and docid in (select distinct docid from orderaware_supv_label);

    }


  }

  pipeline.pipelines.bestpick: [
    # "ext_prepare_document", "ext_holdout_document",
    "ext_eval_orderaware_bestpick",
    # "ext_eval_orderaware_bestpick_tess",
    # "ext_eval_orderaware_bestpick_cuni",
    # "f_constraint",
    ]


  ########### pipeline.run: "bestpick"  # DANGER ZONE
  pipeline.run: "bestpick"


  # inference.skip_learning: true

  # pipeline.relearn_from: /lfs/madmax/0/zifei/deepdive/out/2014-05-29T020109
}
