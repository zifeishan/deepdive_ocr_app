deepdive {

  db.default: {
    driver: "org.postgresql.Driver"
    url: "jdbc:postgresql://"${PGHOST}":"${PGPORT}"/"${DBNAME} #"
    user: ${PGUSER}
    password: ${PGPASSWORD}
    dbname: ${DBNAME}
    host: ${PGHOST}
    port: ${PGPORT}
  }


  extraction.extractors: {

    # array_agg(id order by varid, candid, wordid) as arr_id,
    # array_agg(candid order by varid, candid, wordid) as arr_candid,
    # array_agg(wordid order by varid, candid, wordid) as arr_wordid,
    # TAKES VERY LONG
    ########### TODO at least change this to TSV... ############
    # ext_sup_orderaware {
    #   dependencies: ["ext_holdout_document", "ext_prepare_document", "ext_holdout_from_orderaware", "ext_cand_gen"]
    #   input: """select 
    #     docid,
    #     array_agg(candidate_id order by varid, candid, wordid) as arr_candidate_id,
    #     array_agg(varid order by varid, candid, wordid) as arr_varid,
    #     array_agg(word order by varid, candid, wordid) as arr_word
    #     from cand_word
    #     group by docid
    #     """
    #   # where docid in (select * from eval_docs)
    #   output_relation: "orderaware_supv_label"
    #   # Supervision dir
    #   # udf: "pypy "${APP_HOME}"/udf/ext_sup_orderaware.py"
    #   # get a sample..
    #   udf: util/extractor_input_writer.py /tmp/ext_sup_orderaware.input
    #   # # Using Evaluation dir
    #   # udf: "pypy "${APP_HOME}"/udf/ext_sup_orderaware.py "${EVAL_DIR}
    #   parallelism: ${MAX_PARALLELISM}
    #   before: ${APP_HOME}"/udf/before_sup_orderaware.sh"
    #   # after: ${APP_HOME}"/udf/after_sup_orderaware.sh"
    #   input_batch_size: 1
    #   output_batch_size: 10000
    # }

    # Use Levenshtein distance
    ext_eval_orderaware_bestpick {
      dependencies: ["ext_holdout_document", "ext_prepare_document", "ext_holdout_from_orderaware"]
      input: """select 
        docid,
        array_agg(candidate_id order by varid, candid, wordid) as arr_candidate_id,
        array_agg(varid order by varid, candid, wordid) as arr_varid,
        array_agg(word order by varid, candid, wordid) as arr_word
        from cand_word
        where docid in (select * from eval_docs)
        group by docid
        """
      # where docid in (select * from eval_docs)
      output_relation: "orderaware_eval_label_bestpick"
      # udf: util/extractor_input_writer.py /tmp/ext_bestpick.input
      # udf: "pypy "${APP_HOME}"/udf/ext_sup_orderaware.py "${BESTPICK_DIR} ${EVAL_DIR} 0 0 ${BESTPICK_SAMPLE_SIZE}

      # FIND MATCHES (need to clean cand_word)
      udf: "pypy "${APP_HOME}"/udf/ext_sup_orderaware.py "${BESTPICK_DIR} ${EVAL_DIR} 0 3

      # # Opt(gen) Evaluation
      # udf: "pypy "${APP_HOME}"/udf/ext_sup_orderaware.py "${BESTPICK_DIR} ${EVAL_DIR} 0 0

      # udf: util/extractor_input_writer.py /tmp/sample_ext_ext_bestpick.txt
      parallelism: ${MAX_PARALLELISM}
      before: ${APP_HOME}"/udf/before_sup_orderaware_bestpick.sh orderaware_eval_label_bestpick"
      # after: ${APP_HOME}"/udf/after_sup_orderaware.sh"
      input_batch_size: 1
      output_batch_size: 10000
    }

    # Use Levenshtein distance
    ext_eval_orderaware_bestpick_evalgen {
      dependencies: ["ext_holdout_document", "ext_prepare_document", "ext_holdout_from_orderaware"]
      input: """select 
        docid,
        array_agg(candidate_id order by varid, candid, wordid) as arr_candidate_id,
        array_agg(varid order by varid, candid, wordid) as arr_varid,
        array_agg(word order by varid, candid, wordid) as arr_word
        from cand_word
        where docid in (select * from eval_docs)
        group by docid
        """
      # where docid in (select * from eval_docs)
      output_relation: "orderaware_eval_label_bestpick"
      # Opt(gen) Evaluation
      udf: "pypy "${APP_HOME}"/udf/ext_sup_orderaware.py "${BESTPICK_EVALGEN_DIR} ${EVAL_DIR} 0 0

      # udf: util/extractor_input_writer.py /tmp/sample_ext_ext_bestpick.txt
      parallelism: ${MAX_PARALLELISM}
      before: ${APP_HOME}"/udf/before_sup_orderaware_bestpick.sh orderaware_eval_label_bestpick"
      # after: ${APP_HOME}"/udf/after_sup_orderaware.sh"
      input_batch_size: 1
      output_batch_size: 10000
    }

    # Use trigram distance
    ext_eval_orderaware_bestpick_trgm {
      dependencies: ["ext_holdout_document", "ext_prepare_document", "ext_holdout_from_orderaware"]
      input: """select 
        docid,
        array_agg(candidate_id order by varid, candid, wordid) as arr_candidate_id,
        array_agg(varid order by varid, candid, wordid) as arr_varid,
        array_agg(word order by varid, candid, wordid) as arr_word
        from cand_word
        where docid in (select * from eval_docs)
        group by docid
        """
      # where docid in (select * from eval_docs)
      output_relation: "orderaware_eval_label_bestpick_trgm"
      # udf: util/extractor_input_writer.py /tmp/ext_bestpick.input
      udf: "pypy "${APP_HOME}"/udf/ext_sup_orderaware_trigramdist.py "${BESTPICK_DIR} ${EVAL_DIR} 0.1 0.9 0.2
      parallelism: ${MAX_PARALLELISM}
      before: ${APP_HOME}"/udf/before_sup_orderaware_bestpick.sh orderaware_eval_label_bestpick_trgm"
      # after: ${APP_HOME}"/udf/after_sup_orderaware.sh"
      input_batch_size: 1
      output_batch_size: 10000
    }


  }

  pipeline.pipelines.bestpick: [
    # "ext_eval_orderaware_bestpick",
    "ext_eval_orderaware_bestpick_evalgen",
    # "ext_eval_orderaware_bestpick_trgm",
    ]


  ########### pipeline.run: "bestpick"  # DANGER ZONE
  pipeline.run: "bestpick"


  # inference.skip_learning: true

  # pipeline.relearn_from: /lfs/madmax/0/zifei/deepdive/out/2014-05-29T020109
}
